package com.app.basevideo.framework.manager;import android.os.Handler;import android.os.Looper;import com.app.basevideo.framework.Priority;import com.app.basevideo.framework.UniqueId;import com.app.basevideo.framework.listener.AbsMessageListener;import com.app.basevideo.framework.listener.MessageListener;import com.app.basevideo.framework.listener.TaskNotFoundListener;import com.app.basevideo.framework.message.AbsResponsedMessage;import com.app.basevideo.framework.message.AbsTaskMessage;import com.app.basevideo.framework.message.CommonMessage;import com.app.basevideo.framework.message.TaskMessage;import com.app.basevideo.framework.task.AbsMessageTask;import com.app.basevideo.framework.task.MessageTask;import com.app.basevideo.framework.util.CmdConvertHelper;import com.app.basevideo.framework.util.LogUtil;import com.app.basevideo.framework.util.MessageHelper;import com.app.basevideo.framework.util.ThreadHelper;import java.util.ArrayList;import java.util.LinkedList;/** * 消息管理器，单例 {@link #getInstance()}模式，对外提供消息框架使用接口。 * <p/> * <p> * <h3>作用</h3> * 消息框架提供了模块解耦(单工程多模块或多个工程）模块间通信的一种方式。<br> * 包含3种业务类型： * <ul> * <li>自定义（除了短连接和长连接以外的）{@link ManagerImpl} * </ul> * </p> * <p/> * <p> * <h3>用法</h3> * 消息框架提供给模块间一种新的交互形式，通过发消息{@link AbsTaskMessage} * 来完成，且每个功能点需要定义一个唯一命令号。<br> * 编码实现上一般需要3步， * <ol> * <li>定义一个唯一命令号，定义规范：<br> * <li>编写处理函数，即创建相应的{@link AbsMessageTask} * <li>最后在调用的地方发出消息{@link #sendMessage} * </ol> * 如一个模块页面AActivity要调起另一个模块的页面BActivity，首先定义一个全局唯一命令号为2001001， * BActivity代码中增加static代码段 * ，或在BActivity所在模块创建一个Static结尾的文件，如BStatic.java，同样增加static代码段： * <p/> * <pre> * public class BActivity extends Activity { * 		static { * 			// 注册Custom任务 * 			MessageTask.CustomRunnable<IntentConfig> runnable = new MessageTask.CustomRunnable<IntentConfig>() { * 				&#064;Override * 				public CommonMessage<?> run(TaskMessage<IntentConfig> message) { * 					if (message == null || message.getData() == null) { * 						return null; *                    } * * 					message.getData().startActivity(Mainctivity.class); * 					return null; *                } *            }; * * 			MessageTask task = new MessageTask(2001001, runnable); * 			task.setType(MessageTask.TASK_TYPE.SYNCHRONIZED); * 			MessageManager.getInstance().registerTask(task); *        } * 		... * *    } * </pre> * <p/> * 在AActivity调起BActivity的地方发消息：<br> * <p/> * <pre> * IntentConfig cfg = new IntentConfig(AActivity.this); * TaskMessage msg = new TaskMessage&lt;IntentConfig&gt;(2001001, cfg); * MessageManager.getInstance().sendMessage(msg); * </pre> * <p/> * </p> */public class MessageManager {    private static MessageManager sInstance = null;    private ManagerImpl mManagerImpl = null;    private Handler mUIHandler = null;    private final static String MODULE_NAME = "msgmgr";    /**     * 获取全局单例的消息管理器     *     * @return     */    public static MessageManager getInstance() {        if (null == sInstance) {            synchronized (MessageManager.class) {                if (null == sInstance) {                    sInstance = new MessageManager();                }            }        }        return sInstance;    }    /**     * 构造方法，初始化各个实例     */    private MessageManager() {        mManagerImpl = new ManagerImpl(this);        mUIHandler = new Handler(Looper.getMainLooper());    }    /**     * 根据不同的cmd查找相应的管理器     *     * @param cmd 消息命令行     * @return 返回相应的管理器，若cmd区间匹配出错，则返回null，同时打印"cmd invalid"的logcat error日志     */    private Manager<?, ?, ?> getManager(int cmd) {        MessageHelper.TYPE type = MessageHelper.getMessageType(cmd);        if (type == MessageHelper.TYPE.CUSTOM) {            return mManagerImpl;        } else {            LogUtil.e("cmd invalid");            return null;        }    }    /**     * 发送消息，不支持的消息类型无法发送，调试模式打印error日志     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param absTaskMessage {@link TaskMessage}消息     * @see     */    public boolean sendMessage(AbsTaskMessage<?> absTaskMessage) {        if (absTaskMessage == null) {            return false;        }        if (absTaskMessage instanceof TaskMessage) {            return mManagerImpl.dispatchMessage((TaskMessage<?>) absTaskMessage, null);        } else {            LogUtil.e("absTaskMessage invalid" + CmdConvertHelper.getInstance().getNameByCmd(absTaskMessage.getCmd()));            return false;        }    }    /**     * 发送消息，不支持的消息类型无法发送     * <p/>     * <p>     * <b><font color=red>在子线程中调用发送消息</font>     * </p>     *     * @param absTaskMessage 只允许是{@link TaskMessage}消息     * @see #sendMessage     */    public void sendMessageFromBackground(final AbsTaskMessage<?> absTaskMessage) {        if (absTaskMessage == null) {            return;        }        mUIHandler.post(new Runnable() {            @Override            public void run() {                sendMessage(absTaskMessage);            }        });    }    /**     * 发送消息到一个任务去执行     * <p/>     * <p>     * 场景：执行一个异步处理任务，和{@link #runTask(MessageTask, Class)}     * 的不同在于sendMessage不关注处理结果<br>     * 示例：     * <p/>     * <pre>     * MessageTask task = new MessageTask(MessageConfig.BASE_CUSTOM_CMD, new CustomRunnable<String>() {     *     * 		&#064;Override     * 		public CommonMessage<?> run(TaskMessage<String> absTaskMessage) {     * 			if (absTaskMessage == null || (!(absTaskMessage instanceof TaskMessage))) {     * 				return null;     *            }     * 			...// 执行一个db操作     * 			return null;     *        }     *    });     * 	task.setParallel(TiebaIMConfig.getParallel());     * 	task.setType(MessageTask.TASK_TYPE.ASYNCHRONIZED);     * 	task.setPriority(BdAsyncTaskPriority.SUPER_HIGH);     * 	TaskMessage<String> customMsg = new TaskMessage<String>(MessageConfig.BASE_CUSTOM_CMD);     * 	MessageManager.getInstance().sendMessage(customMsg, task);     * </pre>     * <p/>     * </p>     *     * @param absTaskMessage 消息     * @param task           接收消息并处理的任务     * @see #runTask     */    public void sendMessage(AbsTaskMessage<?> absTaskMessage, AbsMessageTask task) {        if (absTaskMessage == null) {            return;        }        if (absTaskMessage instanceof TaskMessage && task instanceof MessageTask) {            mManagerImpl.dispatchMessage((TaskMessage<?>) absTaskMessage, (MessageTask) task);        } else {            LogUtil.e("absTaskMessage and task invalid:" + CmdConvertHelper.getInstance().getNameByCmd(absTaskMessage.getCmd()));        }    }    /**     * 查找同一个tag的所有的custom消息     *     * @param tag 消息tag，用来查找所有消息tag等于参数的消息     * @return custom消息数组     */    public LinkedList<TaskMessage<?>> findCustomMessage(UniqueId tag) {        return mManagerImpl.findMessage(tag);    }    /**     * 根据消息命令号和消息tag查找匹配的消息集合     *     * @param cmd 消息命令号     * @param tag 消息tag     * @return 消息数组     */    @SuppressWarnings("rawtypes")    public LinkedList<? extends AbsTaskMessage> findMessage(int cmd, UniqueId tag) {        Manager<?, ?, ?> m = getManager(cmd);        if (m != null) {            return m.findMessage(cmd, tag);        } else {            LogUtil.e("cmd invalid");            return null;        }    }    /**     * 根据消息命令号和消息tag删除匹配的消息     * <p/>     * <p>     * 移除消息时，同时会触发执行移除消息的rule<br>     * 场景：比如某个自定义rule截获并保存了某个消息引用，其他模块要删除消息时，自定义rule所在模块就需要同时注册并实现     * </p>     *     * @param cmd 命令号     * @param tag 标签     */    public void removeMessage(int cmd, UniqueId tag) {        Manager<?, ?, ?> m = getManager(cmd);        if (m != null) {            m.removeMessage(cmd, tag);        } else {            LogUtil.e("cmd invalid");        }    }    /**     * 删除消息tag等于参数tag的custom消息，同时会触发执行移除消息的rule     *     * @param tag     */    public void removeCustomMessage(UniqueId tag) {        mManagerImpl.removeMessage(tag);    }    /**     * 从所有消息中删除消息tag等于参数tag的消息，同时会触发执行移除消息的rule     *     * @param tag     */    public void removeMessage(UniqueId tag) {        removeCustomMessage(tag);    }    /**     * 终止responsedMessage的传递     * <p>     * 场景：同一个响应消息可能被多个listener监听，在某个listener里面处理后，如果需要终止不被其他listener处理，     * 则可以调用abortResponsedMessage，这种情况下，listener往往需要配合listener优先级     * {@link Priority} 一起使用     * </p>     *     * @param absResponsedMessage     */    public void abortResponsedMessage(AbsResponsedMessage<?> absResponsedMessage) {        if (absResponsedMessage == null) {            return;        }        int cmd = absResponsedMessage.getCmd();        Manager<?, ?, ?> m = getManager(cmd);        if (m != null) {            m.abort();        }    }    /**     * 注册任务     * <p/>     * <b><font color=red>只允许主线程调用</font>     * <p/>     * 注册的任务如果没有全局性需求，需要使用者调用{@link #unRegisterTask}     *     * @param task 类型只能是{@link MessageTask}     * @see #unRegisterTask     */    public void registerTask(AbsMessageTask task) {        if (task == null) {            return;        }        ThreadHelper.checkMainThread();        if (task instanceof MessageTask) {            mManagerImpl.registerTask((MessageTask) task);        } else {            LogUtil.e("task invalid");        }    }    /**     * 根据命令号查找任务     *     * @param cmd     * @return 消息任务     */    public AbsMessageTask findTask(int cmd) {        AbsMessageTask task = null;        MessageHelper.TYPE type = MessageHelper.getMessageType(cmd);        if (MessageHelper.TYPE.CUSTOM == type) {            task = mManagerImpl.findTask(cmd);        }        return task;    }    /**     * 查找全部CustomTasks     *     * @return     */    public ArrayList<MessageTask> findCustomTasks() {        return mManagerImpl.findTasks();    }    /**     * 根据命令号注销任务     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param cmd 命令号     * @see #registerTask     */    public void unRegisterTask(int cmd) {        ThreadHelper.checkMainThread();        Manager<?, ?, ?> m = getManager(cmd);        if (m != null) {            m.unRegisterTask(cmd);        }    }    /**     * 注册{@link AbsMessageListener}类型的消息监听（to do...名字和实现不符）     *     * @param listener 监听器     */    public void registerListenerFromBackground(final AbsMessageListener<?> listener) {        if (listener == null) {            return;        }        if (ThreadHelper.isMainThread()) {            registerListener(listener);        } else {            mUIHandler.post(new Runnable() {                @Override                public void run() {                    registerListener(listener);                }            });        }    }    /**     * 注册responsedMessage的事件监听     * <p/>     * <p>     * <b><font color=red>禁止在事件回调里面调用此方法，否则抛异常</font><br>     * <b><font color=red>只允许主线程调用</font>     * </p>     * <p>     * 注册的消息监听如果没有全局性需求，需要使用者调用{@link #unRegisterListener}来注销监听<br>     * 场景：比如一个activity注册了一个自己发起的http任务返回的消息监听，页面销毁时需要注销此消息监听，否则会<b><font     * color=red>引起内存泄露</font>     * </p>     *     * @param listener 监听器     * @see #unRegisterListener(AbsMessageListener)     */    public void registerListener(final AbsMessageListener<?> listener) {        if (listener == null) {            return;        }        if (ThreadHelper.isMainThread()) {            registerListenerInternal(listener);        } else {            mUIHandler.post(new Runnable() {                @Override                public void run() {                    registerListenerInternal(listener);                }            });        }    }    private void registerListenerInternal(AbsMessageListener<?> listener) {        if (listener == null) {            return;        }        ThreadHelper.checkMainThread();        MessageHelper.TYPE type = MessageHelper.getMessageType(listener.getCmd());        if (type == MessageHelper.TYPE.CUSTOM && listener instanceof MessageListener) {            mManagerImpl.registerListener(0, (MessageListener) listener);        } else {            LogUtil.e("listener invalid" + CmdConvertHelper.getInstance().getNameByCmd(listener.getCmd()));        }    }    /**     * 注册事件监听，带有命令号和监听器注册监听重载     * <p/>     * <p>     * <b><font color=red>禁止在事件回调里面调用此方法，否则抛异常</font><br>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param cmd      不能是零     * @param listener listener中的域cmd必须是0     * @see #registerListener(AbsMessageListener)     * @see #unRegisterListener(AbsMessageListener)     */    public void registerListener(final int cmd, final AbsMessageListener<?> listener) {        if (listener == null) {            return;        }        if (ThreadHelper.isMainThread()) {            registerListenerInternal(cmd, listener);        } else {            mUIHandler.post(new Runnable() {                @Override                public void run() {                    registerListenerInternal(cmd, listener);                }            });        }    }    private void registerListenerInternal(int cmd, AbsMessageListener<?> listener) {        if (listener == null) {            return;        }        ThreadHelper.checkMainThread();        MessageHelper.TYPE type = MessageHelper.getMessageType(cmd);        if (type == MessageHelper.TYPE.CUSTOM && listener instanceof MessageListener) {            mManagerImpl.registerListener(cmd, (MessageListener) listener);        } else {            LogUtil.e("listener invalid" + CmdConvertHelper.getInstance().getNameByCmd(cmd) + "|"                    + CmdConvertHelper.getInstance().getNameByCmd(listener.getCmd()));        }    }    /**     * 注销responsedMessage的事件监听     * <p/>     * <p>     * <b><font color=red>禁止在事件回调里面调用此方法，否则抛异常</font><br>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param listener     * @see #unRegisterListener(UniqueId)     */    public void unRegisterListener(final AbsMessageListener<?> listener) {        if (listener == null) {            return;        }        if (ThreadHelper.isMainThread()) {            unRegisterListenerInternal(listener);        } else {            mUIHandler.post(new Runnable() {                @Override                public void run() {                    unRegisterListenerInternal(listener);                }            });        }    }    private void unRegisterListenerInternal(AbsMessageListener<?> listener) {        if (listener == null) {            return;        }        ThreadHelper.checkMainThread();        int cmd = listener.getCmd();        if (cmd != 0) {            Manager<?, ?, ?> m = getManager(cmd);            if (m != null) {                m.unRegisterListener(listener);            }        } else {            mManagerImpl.unRegisterListener(listener);        }    }    /**     * 注销相同tag的responsedMessage的事件监听，tag生成是一个全局唯一标记值{@link UniqueId#gen()}     * <p/>     * <p>     * <b><font color=red>禁止在事件回调里面调用此方法，否则抛异常</font><br>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param tag 监听器tag，表示一类监听器，使用者可以把认为相关的监听器的tag设置为同一个tag，     *            比如一个activity创建时注册了多个不同的消息监听器实例     *            ，页面销毁时需要全部注销，就可以在注册时为每个监听器设置统一个tag     *            ，注销时直接用这个tag就可以注销所有和这个tag关联的监听器     * @see #unRegisterListener(AbsMessageListener)     */    public void unRegisterListener(final UniqueId tag) {        if (ThreadHelper.isMainThread()) {            unRegisterListenerInternal(tag);        } else {            mUIHandler.post(new Runnable() {                @Override                public void run() {                    unRegisterListenerInternal(tag);                }            });        }    }    private void unRegisterListenerInternal(UniqueId tag) {        mManagerImpl.unRegisterListener(tag);    }    /**     * 设置sticky模式，注册responsedMessage的事件监听时     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     * <p>     * 如果此消息被分发过，则会在后续注册同一个命令号的消息监听器时， 直接触发消息派发给当前要注册的监听器     * </p>     * <p>     * 场景：类似Android本身的粘性广播     * {@link android.content.Context#sendStickyOrderedBroadcast(android.content.Intent, android.content.BroadcastReceiver, Handler, int, String, android.os.Bundle)}     * </p>     *     * @param cmd 命令号     * @see #registerListener(AbsMessageListener)     * @see #unRegisterStickyMode(int))     */    public void registerStickyMode(int cmd) {        ThreadHelper.checkMainThread();        Manager<?, ?, ?> m = getManager(cmd);        if (m != null) {            m.registerStickyMode(cmd);        }    }    /**     * 取消sticky模式     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param cmd 命令号     * @see #registerStickyMode(int)     */    public void unRegisterStickyMode(int cmd) {        ThreadHelper.checkMainThread();        Manager<?, ?, ?> m = getManager(cmd);        if (m != null) {            m.unRegisterStickyMode(cmd);        }    }    /**     * 分发responsedMessage     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     * <p/>     * <p>     * 分发消息多用于两种场景：     * <ol>     * <li>框架内部处理的响应，如http或custom消息的响应返回，开发者只需实现相应命令号的监听器即可     * <li>开发者可以手动构造一个命令号的响应消息，调用此接口，监听器同样能收到消息     * </ol>     * </p>     *     * @param absResponsedMessage 响应待分发的消息，必须是{@link CommonMessage}子类     */    public void dispatchResponsedMessage(AbsResponsedMessage<?> absResponsedMessage) {        if (absResponsedMessage == null) {            LogUtil.e("absResponsedMessage is null!!!");            return;        }        // 合并子线程发送响应消息逻辑        final AbsResponsedMessage<?> absResponsedMessage2UI = absResponsedMessage;        if (!ThreadHelper.isMainThread()) {            mUIHandler.post(new Runnable() {                @Override                public void run() {                    dispatchResponsedMessage(absResponsedMessage2UI);                }            });            return;        }        int cmd = absResponsedMessage.getCmd();        MessageHelper.TYPE type = MessageHelper.getMessageType(cmd);        if (type == MessageHelper.TYPE.CUSTOM && absResponsedMessage instanceof CommonMessage<?>) {            mManagerImpl.dispatchResponsedMessage((CommonMessage<?>) absResponsedMessage);        } else {            LogUtil.e("absResponsedMessage invalid:CMD=" + CmdConvertHelper.getInstance().getNameByCmd(cmd) + " Class="                    + absResponsedMessage.getClass().getName());        }    }    /**     * 分发responsedMessage 供外部调用，可以在子线程使用     * <p>     * <b><font color="red">已经弃用，请直接使用{@link #dispatchResponsedMessage}     * </font></b>     * </p>     *     * @param absResponsedMessage     */    @Deprecated    public void dispatchResponsedMessageToUI(final AbsResponsedMessage<?> absResponsedMessage) {        dispatchResponsedMessage(absResponsedMessage);    }    /**     * 设置找不到task时的回调     * <p/>     * <p>     * 此回调不支持多个，开发者可以全局设置一个监听器，场景，如检查不到某个命令号的响应任务时，可以打印错误日志，或者动态加载相应模块以注册任务     * </p>     *     * @param taskNotFoundListener     */    public void setNotFindTaskListener(TaskNotFoundListener<AbsTaskMessage<?>> taskNotFoundListener) {        Manager.setNotFindTaskListener(taskNotFoundListener);    }    /**     * 执行一个任务并获取任务执行结果     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     * <p/>     * <p>     * 和{@link #sendMessage(AbsTaskMessage, AbsMessageTask)}的不同在于runTask关注获取一个任务的返回值     * </p>     *     * @param cmd 任务命令号     * @param cls 任务返回值类型，传入的类型就是所需要返回的数据的类型，使用者不需要对返回值类型转换     * @return 任务返回值     * @see #sendMessage(AbsTaskMessage, AbsMessageTask)     * @see #runTask(TaskMessage, Class)     * @see #runTask(MessageTask, Class)     * @see #runTask(int, Class, Object))     */    public <T> CommonMessage<T> runTask(int cmd, Class<T> cls) {        return runTask(cmd, cls, null);    }    /**     * 执行一个任务并获取任务执行结果     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param cmd  任务命令号     * @param cls  任务返回值类型，传入的类型就是所需要返回的数据的类型，使用者不需要对返回值类型转换     * @param data 待执行任务所需数据     * @return     */    public <T> CommonMessage<T> runTask(int cmd, Class<T> cls, Object data) {        TaskMessage<Object> taskMessage = null;        if (data != null) {            taskMessage = new TaskMessage<Object>(cmd);            taskMessage.setData(data);        }        return mManagerImpl.runTask(taskMessage, mManagerImpl.findTask(cmd), cls);    }    /**     * 执行一个任务并获取任务执行结果     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param task 任务命令号     * @param cls  任务返回值类型，传入的类型就是所需要返回的数据的类型，使用者不需要对返回值类型转换     * @return     */    public <T> CommonMessage<T> runTask(MessageTask task, Class<T> cls) {        return mManagerImpl.runTask(null, task, cls);    }    /**     * 执行一个任务并获取任务执行结果     * <p/>     * <p>     * <b><font color=red>只允许主线程调用</font>     * </p>     *     * @param taskMessage 任务可以从message里面获取执行所需数据     * @param cls         任务返回值类型，传入的类型就是所需要返回的数据的类型，使用者不需要对返回值类型转换     * @return     */    public <T> CommonMessage<T> runTask(TaskMessage<?> taskMessage, Class<T> cls) {        if (taskMessage == null) {            return null;        }        return mManagerImpl.runTask(taskMessage, mManagerImpl.findTask(taskMessage.getCmd()), cls);    }}